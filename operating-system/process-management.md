# 프로세스
프로그램을 실행시킨 것.  
저장장치에 있는 프로그램(정적)을 실행시키면 메모리로 올라와 프로세스(동적)가 된다.  
한마디로 프로세스는 메모리에 올라와 실행되고 있는 **프로그램의 인스턴스**이다.  

과거의 배치 시스템에서는 1개의 프로세스만 실행가능했기 때문에 실행과정이 단순했으나, 현대의 시분할 시스템에서는 동시에 여러개의 프로세스가 메모리에 존재하고 번갈아가며 실행된다.
각 프로세스들은 PCB(프로세스 정보를 담은 블록)을 가지며 이를 통해 관리된다.  

<br/>

## 프로세스 상태
각 프로세스는 시간에 따라 다양한 상태를 갖는다.  
<img src="https://user-images.githubusercontent.com/46877318/99266066-b9dcdf00-2865-11eb-9604-56a5457a6e77.PNG" width=500>
- **생성(new)**: 프로그램이 메모리로 올라와 PCB가 생성되고 실행할 준비가 되면 준비 단계로 넘어간다.
- **준비(ready)**: CPU는 한번에 하나의 프로세스만 실행가능하므로, 실행 중이 아닌 나머지 프로세스들은 준비 단계에 쌓여 차례를 기다린다.
- **실행(running)**: 프로세스가 CPU를 할당받아 주어진 시간동안 실행된다. 주어진 시간동안 작업이 채 완료되지 않았다면 다시 준비 단계로 들어가 차례를 기다린다.
- **대기(waiting)**: 실행 중인 프로세스가 입출력을 요청했을 때, 입출력이 완료될 때까지 작업을 하지 않아 CPU가 낭비되는 것을 막기 위해 대기 상태로 보낸다.
입출력이 완료되면 다시 준비 단계로 들어가 차례를 기다린다.
- **종료(terminated)**: 작업이 완료되면 실행이 종료된다. PCB도 폐기된다.

<br/>

## PCB(Process Control Block)
각 프로세스의 정보를 담고있는 블록. 프로세스 생성 시 만들어지며 종료 시 폐기된다.  
다음과 같은 정보들이 저장된다.  

<img src="https://user-images.githubusercontent.com/46877318/99267070-cf9ed400-2866-11eb-986c-cdbf07879c70.PNG" width=150>

- **프로세스 상태**: 프로세스의 상태(생성/준비/실행/대기/일시정지)
- **PID(=Process number)**: 고유 식별자
- **PC(Program Counter)**: 다음에 실행할 명령어의 위치
- **레지스터 정보**: 사용하던 레지스터의 값
- **메모리 관리**: 해당 프로세스의 주소공간 정보
- **입출력 상태**: 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등

이 외에도 다양한 정보가 저장되어 있다.

<br/>

## 문맥 교환(Context Switching)
프로세스들의 상태를 바꾸는 작업.  
프로세스 P1과 P2의 문맥 교환 과정:  
① P1의 타임슬라이스 아웃 발생  
② P1의 상태를 PCB1에 저장한다.  
③ PCB2로부터 P2의 상태를 가져온다.  
④ P2가 실행된다.

<br/>

## 프로세스 생성
프로세스는 코드/데이터/스택 영역으로 구성되어 있다. 프로그램을 실행시키면, 운영체제는 프로그램을 가져와 프로세스의 코드영역에 넣고, 데이터·스택영역을 확보한 후 프로세스를 실행시키게 된다.  
- **코드 영역**: 프로그램의 코드가 있는 영역이며, 실행중 변경되지 않으므로 read only로 지정되어 있다.
- **데이터 영역**: 전역변수 또는 static 변수 등 프로그램 종료 전까지 지워지지 않는 데이터들이 저장된 공간. 실행 중 변경될 수 있으므로 read-write로 지정되어 있다.
- **스택 영역**: 지역변수, 매개변수, 리턴값, 돌아갈 주소값 등 **잠깐 사용하고 삭제할 데이터**들이 저장된 공간. 함수 종료 시 제거된다. **컴파일 타임**에 크기가 결정되기 때문에 stack 영역을 초과하면 stack overflow 에러가 발생한다.
- **힙 영역**: 동적 할당에 의해 생성된 동적 변수들이 저장된 공간. 나머지 영역과 달리 **런타임**에 결정된다.  

<br/>

## 프로세스 복사 생성(by fork() system call)
일반적인 프로세스 생성과정은 위와 같고, 기존 프로세스로부터 새 프로세스가 생성되는 경우도 있다. 똑같은 프로세스를 하나 더 만들어야 할 경우에는, 디스크로부터 프로그램을 또 가져와 실행시키는 것이 아니라 이미 실행중인 프로세스를 **fork() 시스템 호출**을 통해 `복제` 하면 된다.  
fork()를 사용해 복사하게 되면, 기존 프로세스는 **부모 프로세스**이고 새 프로세스는 **자식 프로세스**가 된다.  
PCB를 포함한 모든 프로세스 내용이 복사되지만, PCB의 내용 중 PID, 메모리 정보, PPID, CPID가 달라진다.

<br/>

# 스레드
한 프로세스 내에서 실행되는 흐름의 단위. 한 프로세스 안에는 1개 이상의 스레드가 존재한다.  
각 스레드는 그들이 속한 프로세스가 할당받은 메모리 영역 중 `스택` 영역을 제외한 모든 메모리(`코드`, `데이터`, `힙` 영역)을 서로 공유한다.  
(독립적인 스택 영역 == 독립적인 함수 호출 == 독립적인 실행 흐름)  
- **장점**  
자원을 공유함으로써 자원의 중복과 낭비를 막을 수 있고, 공유하기 때문에 새 프로세스를 생성하는 것보다 빠르다.  
정보 교환이 수월하다.  
문맥 교환에 대한 오버헤드가 줄어든다.
- **단점**  
스레드 스케줄링을 고려해야 한다.  
자원을 공유하는 점이 장점이자 단점이 될 수도 있다.(동기화 문제)  
하나의 스레드에 문제가 발생하면 전체 스레드에 영향을 끼친다.(멀티프로세스는 하나의 프로세스가 오류가 나도 다른 프로세스에 영향 X)
