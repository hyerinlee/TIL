# 프로세스
프로세스는 프로그램을 실행시킨 것이다.  
저장장치에 있는 프로그램(정적)을 실행시키면 메모리로 올라와 프로세스(동적)가 된다.  

과거의 배치 시스템에서는 1개의 프로세스만 실행가능했기 때문에 실행과정이 단순했으나, 현대의 시분할 시스템에서는 동시에 여러개의 프로세스가 메모리에 존재하고 번갈아가며 실행된다.
각 프로세스들은 PCB(프로세스 정보를 담은 블록)을 가지며 이를 통해 관리된다.  

<br/>

## 프로세스 상태
각 프로세스는 시간에 따라 다양한 상태를 갖는다.  
<img src="https://user-images.githubusercontent.com/46877318/99266066-b9dcdf00-2865-11eb-9604-56a5457a6e77.PNG" width=500>
- **생성(new)**: 프로그램이 메모리로 올라와 PCB가 생성되고 실행할 준비가 되면 준비 단계로 넘어간다.
- **준비(ready)**: CPU는 한번에 하나의 프로세스만 실행가능하므로, 실행 중이 아닌 나머지 프로세스들은 준비 단계에 쌓여 차례를 기다린다.
- **실행(running)**: 프로세스가 CPU를 할당받아 주어진 시간동안 실행된다. 주어진 시간동안 작업이 채 완료되지 않았다면 다시 준비 단계로 들어가 차례를 기다린다.
- **대기(waiting)**: 실행 중인 프로세스가 입출력을 요청했을 때, 입출력이 완료될 때까지 작업을 하지 않아 CPU가 낭비되는 것을 막기 위해 대기 상태로 보낸다.
입출력이 완료되면 다시 준비 단계로 들어가 차례를 기다린다.
- **종료(terminated)**: 작업이 완료되면 실행이 종료된다. PCB도 폐기된다.

<br/>

## PCB(Process Control Block)
각 프로세스의 정보를 담고있는 블록. 프로세스 생성 시 만들어지며 종료 시 폐기된다.  
다음과 같은 정보들이 저장된다.  

<img src="https://user-images.githubusercontent.com/46877318/99267070-cf9ed400-2866-11eb-986c-cdbf07879c70.PNG" width=150>

- **프로세스 상태**: 프로세스의 상태(생성/준비/실행/대기/일시정지)
- **PID(=Process number)**: 고유 식별자
- **PC(Program Counter)**: 다음에 실행할 명령어의 위치
- **레지스터 정보**: 사용하던 레지스터의 값
- **메모리 관리**: 해당 프로세스의 주소공간 정보
- **입출력 상태**: 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등

이 외에도 다양한 정보가 저장되어 있다.

<br/>

## 문맥 교환(Context Switching)
프로세스들의 상태를 바꾸는 작업.  
프로세스 P1과 P2의 문맥 교환 과정:  
① P1의 타임슬라이스 아웃 발생  
② P1의 상태를 PCB1에 저장한다.  
③ PCB2로부터 P2의 상태를 가져온다.  
④ P2가 실행된다.

<br/>

## 프로세스 생성
프로세스는 코드/데이터/스택 영역으로 구성되어 있다. 프로그램을 실행시키면, 운영체제는 프로그램을 가져와 프로세스의 코드영역에 넣고, 데이터·스택영역을 확보한 후 프로세스를 실행시키게 된다.  
- 코드 영역: 프로그램의 코드가 있는 영역이며, 실행중 변경되지 않으므로 read only이다.
- 데이터 영역: 실행 중 사용될 변수나 파일같은 데이터가 있는 영역.
- 스택 영역: 운영체제가 프로세스를 실행시키는 데 필요한 부가 데이터가 있는 영역.  

요리사 모형에 비유하여 프로그램을 스파게티 만들기라고 한다면, 코드=레시피, 데이터=식재료, 스택=요리도구 이다.  
실제 예시로는 워드프로세서를 예로 들 수 있다. 코드=워드프로세서의 프로그램, 데이터=워드프로세서로 만든 문서, 스택=os가 워드프로세서를 작동시키기 위해 사용하는 각종 부가 데이터.

<br/>

## 프로세스 복사 생성(by fork() system call)
일반적인 프로세스 생성과정은 위와 같고, 기존 프로세스로부터 새 프로세스가 생성되는 경우도 있다. 똑같은 프로세스를 하나 더 만들어야 할 경우에는, 디스크로부터 프로그램을 또 가져와 실행시키는 것이 아니라 이미 실행중인 프로세스를 **fork() 시스템 호출**을 통해 `복제` 하면 된다.  
fork()를 사용해 복사하게 되면, 기존 프로세스는 **부모 프로세스**이고 새 프로세스는 **자식 프로세스**가 된다.  
PCB를 포함한 모든 프로세스 내용이 복사되지만, PCB의 내용 중 PID, 메모리 정보, PPID, CPID가 달라진다.
